<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />

    <!-- BEGIN Info -->
    <meta
      name="description"
      content="Trellis - ."
    />
    <meta name="title" property="og:title" content="Trellis" />
    <meta property="og:type" content="Website" />
    <meta name="image" property="og:image" content="images/thumb.png" />
    <meta
      name="description"
      property="og:description"
      content="Trellis - An open-source, low-config CICD pipeline for serverless applications."
    />
    <meta name="author" content="Trellis" />
    <!-- END Info -->
    <!-- BEGIN favicon -->
    <link
      rel="apple-touch-icon"
      sizes="180x180"
      href="images/favicon/apple-touch-icon.png"
    />
    <link
      rel="icon"
      type="image/png"
      sizes="32x32"
      href="images/favicon/favicon-32x32.png"
    />
    <link
      rel="icon"
      type="image/png"
      sizes="16x16"
      href="images/favicon/favicon-16x16.png"
    />
    <link rel="manifest" href="images/favicon/site.webmanifest" />
    <link
      rel="mask-icon"
      href="images/favicon/safari-pinned-tab.svg"
      color="#5bbad5"
    />
    <link rel="shortcut icon" href="images/favicon/favicon.ico" />
    <meta name="msapplication-TileColor" content="#ffffff" />
    <meta
      name="msapplication-config"
      content="images/favicon/browserconfig.xml"
    />
    <meta name="theme-color" content="#ffffff" />
    <!-- END favicon -->

    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Trellis</title>

    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css"
    />
    <link
      rel="stylesheet"
      href="https://unpkg.com/@tailwindcss/typography@0.2.x/dist/typography.min.css"
    />
    <link rel="stylesheet" href="stylesheets/reset.css" />
    <link rel="stylesheet" href="stylesheets/style.css" />
    <link rel="stylesheet" href="stylesheets/responsive.css" />
  </head>
  <body>
    <header class="mobile-menu-closed">
      <div id="header">
        <a href="/">
          <img src="images/logo/logo-name.svg" />
        </a>
        <nav>
          <a href="#start-here" class="selected">Start Here</a>
          <a href="#case-study">Case Study</a>
            <a href="#presentation">Presentation</a>
          <a href="#our-team">Our Team</a>
          <a
            href="https://github.com/Trellis-Deployment/trellis"
            target="_blank"
            class="icon"
            ><i class="fab fa-github"></i
          ></a>
        </nav>
        <div id="menu">
          <button type="button">
            <svg
              id="mobile-open"
              xmlns="http://www.w3.org/2000/svg"
              fill="none"
              viewBox="0 0 24 24"
              stroke="currentColor"
              aria-hidden="true"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M4 6h16M4 12h16M4 18h16"
              />
            </svg>
            <svg
              id="mobile-close"
              xmlns="http://www.w3.org/2000/svg"
              fill="none"
              viewBox="0 0 24 24"
              stroke="currentColor"
              aria-hidden="true"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M6 18L18 6M6 6l12 12"
              />
            </svg>
          </button>
        </div>
      </div>

      <div id="header-buffer"></div>

      <div id="mobile-menu">
        <a href="#start-here" class="selected">Start Here</a>
        <a href="#case-study">Case Study</a>
        <a href="#presentation">Presentation</a>
        <a href="#our-team">Our Team</a>
        <a href="https://github.com/Trellis-Deployment/trellis" target="_blank"
          ><i class="fab fa-github"></i> GitHub</a
        >
      </div>
    </header>
    <div id="start-here" class="main-section">
      <div class="h-full">
        <div class="static-logo-color"></div>
        <div class="bg-blue">
          <img
            class="sm-screen"
            src="images/logo/logo-name-vertical.png"
          />
          <img class="lg-screen" src="images/logo/trellis-name-white.png" />

          <p class="light-text">
            An open-source<br />
            <span style="color: #F8D3B3;">Low-config</span>
            <span class="text-teal">CI/CD pipeline</span><br />
            for serverless applications.
          </p>
        </div>
      </div>
      <div class="h-full">
        <div class="bg-teal static-logo-teal-light" style="text-align: center;">
          <h2><span>Open-Source. </span><span>Low-Config. <br> </span><span>Team-Oriented. </span></h2>
        </div>
        <div class="bg-teal" style="text-align: center;">
          <h2 class="sm-header">Open-Source. Low-Config. Team-Oriented.</h2>
          <p>
            Trellis handles the complexity of setting up an 
            automated deployment pipeline for serverless applications.
          </p>
          <video autoplay loop muted playsinline>
            <source src="images/trellis-deploy-blue.mp4" type="video/mp4" />
            Your browser does not support the HTML5 Video element.
          </video>
        </div>
      </div>
      <div class="h-full">
        <div class="bg-pink static-logo-pink-light" style="text-align: center;">
          <h2> • <span>Deploy</span> • <span>Promote</span> • <span>Teardown</span> • <br> • <span>Rollback</span> • <span>Test</span> •</h2>
        </div>
        <div class="bg-pink">
          <h2 class="sm-header" style="text-align: center;"> • Deploy • Promote • Teardown • Rollback • Test •</h2>
          <p>
            Trellis simplifies automated deployment pipeline setup for teams that wish to focus 
            on feature development rather than operations.
          </p>
          <video autoplay loop muted playsinline >
            <source
              src="images/video/deploy-promote-teardown-rollback-test.mp4"
              type="video/mp4"
            />
          </video>
        </div>
      </div>
    </div>

    <aside id="toc">
      <ul>
        <!-- Section 1 -->
        <li data-section="section-1" class="selected">
          <a href="#section-1">
            <div>
              <div class="bullet"><div></div></div>
              <p>1. Introduction</p>
            </div>
          </a>
        </li>
        <li data-section="section-1" class="subitem">
          <a href="#section-1-1">
           <div>
            <div class="bullet"><div></div></div>
            <p>1.1 Problem Definition</p>
          </div>
          </a>
        </li>
        <li data-section="section-1" class="subitem">
          <a href="#section-1-2">
           <div>
            <div class="bullet"><div></div></div>
            <p>1.2 CI/CD (Continuous Integration & Continuous Delivery)</p>
          </div>
          </a>
        </li>
        <li data-section="section-1" class="subitem">
          <a href="#section-1-3">
           <div>
            <div class="bullet"><div></div></div>
            <p>1.3 Deployment Environments</p>
          </div>
          </a>
        </li>
        <li data-section="section-1" class="subitem">
          <a href="#section-1-4">
           <div>
            <div class="bullet"><div></div></div>
            <p>1.4 Deployment Pipelines</p>
          </div>
          </a>
        </li>
        <li data-section="section-1" class="subitem">
          <a href="#section-1-5">
           <div>
            <div class="bullet"><div></div></div>
            <p>1.5 Approach 1 - Deploying On-Prem</p>
          </div>
          </a>
        </li>
        <li data-section="section-1" class="subitem">
          <a href="#section-1-6">
           <div>
            <div class="bullet"><div></div></div>
            <p>1.6 Approach 2 - Deploying a Cloud-Hosted Application</p>
          </div>
          </a>
        </li>
        <li data-section="section-1" class="subitem">
          <a href="#section-1-7">
           <div>
            <div class="bullet"><div></div></div>
            <p>1.7 Approach 3 - Deploying a Serverless Application</p>
          </div>
          </a>
        </li>
        <li data-section="section-1" class="subitem">
          <a href="#section-1-8">
           <div>
            <div class="bullet"><div></div></div>
            <p>1.8 Approach 3 - Existing Tools</p>
          </div>
          </a>
        </li>
        <!-- Section 2 -->
        <li data-section="section-2">
          <a href="#section-2">
            <div>
              <div class="bullet"><div></div></div>
              <p>2. Enter Trellis</p>
            </div>
          </a>
        </li>
        <li data-section="section-2" class="subitem">
          <a href="#section-2-1">
            <div>
              <div class="bullet"><div></div></div>
              <p>2.1 What Is Trellis?</p>
            </div>
          </a>
        </li>
        <li data-section="section-2" class="subitem">
          <a href="#section-2-2">
            <div>
              <div class="bullet"><div></div></div>
              <p>2.2 What Can Trellis Do?</p>
            </div>
          </a>
        </li>
        <li data-section="section-2" class="subitem">
          <a href="#section-2-3">
            <div>
              <div class="bullet"><div></div></div>
              <p>2.3 What Is Trellis Composed Of?</p>
            </div>
          </a>
        </li>
        <!-- Section 3 -->
        <li data-section="section-3">
          <a href="#section-3">
            <div>
              <div class="bullet"><div></div></div>
              <p>3. Architecture</p>
            </div>
          </a>
        </li>
        <li data-section="section-3" class="subitem">
          <a href="#section-3-1">
            <div>
              <div class="bullet"><div></div></div>
              <p>3.1 Trellis as a Serverless Application</p>
            </div>
          </a>
        </li>
        <li data-section="section-3" class="subitem">
          <a href="#section-3-2">
            <div>
              <div class="bullet"><div></div></div>
              <p>3.2 Build Server</p>
            </div>
          </a>
        </li>
        <li data-section="section-3" class="subitem">
          <a href="#section-3-3">
            <div>
              <div class="bullet"><div></div></div>
              <p>3.3 Backend</p>
            </div>
          </a>
        </li>
        <li data-section="section-3" class="subitem">
          <a href="#section-3-4">
            <div>
              <div class="bullet"><div></div></div>
              <p>3.4 Dashboard</p>
            </div>
          </a>
        </li>
        <!-- Section 4 -->
        <li data-section="section-4">
          <a href="#section-4">
            <div>
              <div class="bullet"><div></div></div>
              <p>4. Engineering Decisions & Tradeoffs</p>
            </div>
          </a>
        </li>
        <li data-section="section-4" class="subitem">
          <a href="#section-4-1">
            <div>
              <div class="bullet"><div></div></div>
              <p>4.1 Build Server: Lambda vs Fargate</p>
            </div>
          </a>
        </li>
        <li data-section="section-4" class="subitem">
          <a href="#section-4-2">
            <div>
              <div class="bullet"><div></div></div>
              <p>4.2 Sending real-time data to the dashboard</p>
            </div>
          </a>
        </li>
        <!-- Section 5 -->
        <li data-section="section-5">
          <a href="#section-5">
            <div>
              <div class="bullet"><div></div></div>
              <p>5. Future Work</p>
            </div>
          </a>
        </li>
        <!-- Section 6 -->
        <li data-section="section-6">
          <a href="#section-6">
            <div>
              <div class="bullet"><div></div></div>
              <p>6. References</p>
            </div>
          </a>
        </li>
      </ul>
    </aside>

    <div id="case-study" class="main-section">
      <div id="case-study-content">
        <div class="prose">
          <h1>Case Study</h1>
          <!-- Section 1 -->
          <h2 id="section-1">1. Introduction</h2>
          <h3 id="section-1-1">1.1 Problem Definition</h3>
          <p>
            Deployment is the process of moving application code from a developer's machine to infrastructure that serves the application.
            Traditionally, software engineers were tasked with developing code, and operations teams were in charge of deploying that
            code<a href="#reference-1"><sup>1</sup></a>.
            This separation of responsibilities relied on consistent communication, trust,
            and collaboration between development and operations teams to integrate new code despite each team having unique goals,
            responsibilities, and even cultures. Any friction between these teams meant additional time taken between software releases
            for the development team to make corrective code changes or for the operations team to assess, test, and offer feedback on
            problematic features.
          </p>
          <p>
            To speed up development cycles and make application maintenance easier,
            many organizations have adopted the cultural philosophy of DevOps,
            under which development and operations are combined into a single team.
            DevOps strengthens the bond between development and operations tasks so that code can be incrementally written, tested,
            and monitored as it is developed. This enables quicker feedback on iterations which means shorter development cycles
            and quicker delivery of features to production. However, not all developers have experience with the steps required to deploy code,
            and even fewer have experience with the nuances of deploying to the cloud. Teams whose developers fit this description need a
            solution that takes on much of the operations responsibility so they can focus on development while still benefiting from a
            culture of DevOps.
          </p>
          <h3 id="section-1-2">1.2 CI/CD (Continuous Integration & Continuous Delivery)</h3>
          <p>
            As development teams work together to iterate on an application,
            an important measure is validating that each individual developer's code changes are acceptable for integration into the application's
            main code base. Software development teams are often composed of multiple engineers, so it is beneficial to combine their
            contributions into a single functioning and testable artifact that is a candidate for being released to end users.
            With an interest in rapid release cycles, DevOps teams turn to automation to accomplish such integration,
            and this automated process is known as continuous integration<a href="#reference-2"><sup>2</sup></a>.
          </p>
          <p>
            A fundamental step for teams to achieve continuous integration is committing all code changes to a shared repository
            in a version control system like GitHub. With all of an application's code being sent to the same place,
            development teams can track application revisions, solve code merge conflicts, and run automated processes like testing
            or code quality scans every time a change occurs. As such, a version control system is key to continuous integration
            as it acts as a single source of versioned code - or a source of truth - to build a comprehensive artifact that can be deployed
            as a full application.
          </p>
          <p>
            However, continuous integration is only part of the story. Once code contributions are compiled into a single artifact,
            the functionality of the artifact itself should be tested to ensure that it is ready for end users.
            Teams can achieve this by deploying it to infrastructure that runs the application and makes it available for developers to interact
            with it. They can then scrutinize its functionality and run various tests to assess its performance<a href="#reference-3"><sup>3</sup></a>.
            As a result, developers can verify application changes across multiple dimensions and develop confidence
            that they are ready for production. Continuous delivery is a DevOps practice that automatically deploys all code changes so teams
            can carry out these validation steps and effectively prepare a code artifact for a release to production<a href="#reference-3"><sup>3</sup></a>.
            Deployment environments play a key role in this practice.
          </p>
          <h3 id="section-1-3">1.3 Deployment Environments</h3>
          <p>
            An early concern for teams when it comes to continuous delivery is to separate the resources which serve the application to
            customers and the resources which developers utilize for pre-production testing.
            This is to ensure that end users are not exposed to potentially-problematic code that has not been fully vetted.
            The discrete sets of resources to which an application is deployed are referred to as environments<a href="#reference-4"><sup>4</sup></a>. 
          </p>
          <p>
            A common set of deployment environments are development, staging, and production<a href="#reference-5"><sup>5</sup></a>. 
          </p>
          <p>
            Development environments allow developers to test their potentially-problematic changes by deploying them in isolation.
            Introducing this code to real users might expose them to breaking changes or render the application unavailable,
            which could have a real monetary cost for organizations that depend on users for profit.
            Applications that run in development environments are not exposed to end users and are instead only used by developers
            for trying out their new code and making sure that it runs. As such, these environments do not generally need the same
            resource capacity as downstream environments where more-intensive verifications take place.
            Further, development environments can be updated more rapidly and thus allow for faster iteration for the developers utilizing them<a href="#reference-6"><sup>6</sup></a>.
          </p>
          <p>
            Staging environments<a href="#reference-7"><sup>7</sup></a> are like development environments in that end users do not interact with them.
            However, they tend to be more complex with more-robust resources because they are meant to replicate
            the environment that will serve end users. This enables teams to test how the application will behave for end users
            and also provides a suitable target for simulating real-world interaction with the application via methods like UI testing,
            load testing, integration testing, API reliability testing, etc.
          </p>
          <p>
            Lastly, production environments contain the infrastructure that serves end users.
            Code that runs on this environment has generally been thoroughly vetted enough to be trusted for release.
            The resources for this environment must have sufficient capacity to serve the application at scale.
            As such, the production environment may contain many servers in order to handle the web traffic,
            request processing and storage required by the application.
          </p>
          <img class="lazy" data-src="images/diagrams/section1/dev-stage-prod.png"/>
          <h3 id="section-1-4">1.4 Deployment Pipelines</h3>
          <p>
            Simply having multiple deployment environments is not enough to ensure that a code artifact is ready for production.
            What is needed is a process for moving code artifacts from version control through these environments so that they
            can be increasingly vetted and improved as they progress toward production. This process is referred to as a deployment pipeline.
            A deployment pipeline's early stages (e.g. development environment) can run automated tests to find most problems yielding early
            feedback, while later stages (e.g. staging environment) often provide slower, even manual probing of features.
            When an application's developers are satisfied with its performance in one environment,
            they can progress it to the next environment in a step called promotion. As code is promoted through a pipeline,
            teams can develop confidence in its capacity to adequately serve users.
          </p>
          <p>
            One option is for teams to manually promote code through a deployment pipeline's environments.
            This might entail cloning code from a version control system, injecting environment variables that the application uses,
            and entering a series of commands to deploy the code and run relevant tests. While this technique yields the productivity
            gains of a deployment pipeline, it is potentially error-prone as it requires that the developer execute the right steps
            in the proper order every time. In addition, this manual approach takes up valuable time that could otherwise be spent on
            continuously improving the application. A more-effective approach is to automate the operations duties related to deployment
            so teams can reap the benefits of a DevOps culture and continuous delivery while still being able to focus their time and
            energy on development-related tasks.
          </p>
          <p>
            Automatic deployments are often initiated in response to changes to the source code in a team's version control system,
            such as GitHub. For instance, engineers may develop new application features on the main branch of their GitHub repository
            and this branch might have a development environment associated with it. Their deployment pipeline might be configured
            so that any commits to the branch will trigger a deployment of the updated code to the corresponding environment.
            Other teams may want to retain manual control over promoting code to production environments to make it impossible for sneaky bugs
            to reach end users without explicit approval from a human. Nonetheless, even they can benefit from automating the deployment steps
            that take place after manual approval.
          </p>
          <p>
            In an automated deployment pipeline, the bulk of such automation is handled by a build server<a href="#reference-8"><sup>8</sup></a>.
            Its work generally involves:
          </p>
          <ul>
            <li>Obtaining the code to be deployed from source control</li>
            <li>Running any commands or scripts to deploy resources</li>
            <li>Conducting testing (e.g. unit tests) prior to deployment</li>
            <li>
              Producing deployment logs which indicate deployment status to developers and convey any errors that may have occurred
              throughout the process
            </li>
          </ul>
          <p>
            A common feature of automated deployment pipeline tools is a centralized dashboard which teams can use to interact
            with their pipelines. This dashboard can display deployment logs, provide control over the manual steps in the deployment pipeline,
            and generally provide transparency into the processes carried out by the build server.
          </p>
          <p>
            Three major approaches to deployment include on-premise, cloud-hosted, and serverless paradigms.
            Deployment pipelines can be implemented differently depending on the infrastructure involved in each approach.
          </p>
          <h3 id="section-1-5">1.5 Approach 1 - Deploying On-Prem</h3>
          <p>
            One deployment approach involves deploying an application to on-premises (on-prem) equipment.
            ‘On-prem' refers to server hardware that is managed and fully-controlled by the developing organization.
          </p>
          <p>
            Maintaining on-prem infrastructure often requires significant capital expenditures to obtain the hardware necessary
            to host the application and keep up application performance.
            This includes the time and monetary costs related to all aspects of caring for machines such as replacing parts,
            ensuring reliable power delivery, maintaining network connections, physical security, and more.
          </p>
          <p>
            Deploying a three-tier application on-prem would involve deploying web, application and database servers on the company's
            own hardware. An on-prem deployment pipeline tool will deploy code to staging and production environments that exist on
            these on-prem machines. Meanwhile, development environments would likely exist on the team's local machines which are capable
            of hosting all three application tiers and replicating their performance in production.
          </p>
          <img class="lazy" data-src="images/diagrams/section1/on-premisses.png"/>

          <h3 id="section-1-6">1.6 Approach 2 - Deploying a Cloud-Hosted Application</h3>
          <p>
            For small teams that lack the time or expertise needed to maintain physical infrastructure,
            it makes sense to avoid the responsibilities of on-prem hosting in favor of cloud hosting<a href="#reference-9"><sup>9</sup></a>.
            Cloud hosting refers to deploying an application on machines managed by a third party,
            such as Amazon Web Services (AWS). As the cloud provider, AWS would manage the physical servers on behalf of the team
            and run the data center locations where these servers are located. The team would only need to deploy their code
            to the cloud and rest assured that the underlying hardware will be maintained as needed. While the developers
            are still responsible for configuring aspects of their infrastructure like networks, data storage, and scalability,
            offloading physical server management lets them place more focus on application development and less on systems administration.
          </p>
          <p>
            Cloud providers generally employ some form of consumption-based billing, often measured in time and/or compute resources.
            Depending on application usage patterns, this can be more expensive than running on-premise hardware,
            but it allows teams to serve their users without requiring a large initial up-front infrastructure investment.
            In essence, they can run their code on enterprise-level machines without having to buy enterprise-level machines.
          </p>
          <p>
            The work of a deployment pipeline for a cloud-hosted application is similar to that of on-prem deployments for simple applications.
            As long as the development team is willing to generate hardware specifications of the servers for a cloud provider to provision,
            the application components - the web server, application server, and database server - can just be moved to the cloud provider's
            infrastructure. As a result, the servers hosting the staging and production environments can be similar to those used
            in the on-prem deployment approach, and developers can often continue to use local development environments to refine preliminary
            code changes.
          </p>
          <img class="lazy" data-src="images/diagrams/section1/cloud-hosted.png" />
          <h3 id="section-1-7">1.7 Approach 3 - Deploying a Serverless Application</h3>
          <p>
            Serverless is a model which can be understood as a subclass of cloud-hosted applications.
            Rather than hosting virtualized versions of web, application and database servers,
            the cloud providers expose services which abstract away the underlying virtual servers (on top of the physical ones)<a href="#reference-10"><sup>10</sup></a>.
            The canonical example of serverless is functions-as-a-service (FaaS). FaaS functions are individually-defined
            units of executable logic, and when invoked the cloud provider runs spins up instances of individual functions on their servers.
            These instances are ephemeral, or impermanent, in that they are provisioned, invoked, and then deprovisioned all according to demand.
          </p>
          <p>
            Serverless resources generally have the following characteristics<a href="#reference-11"><sup>11</sup></a>:
          </p>
          <ul>
            <li>Auto-scaling - resources will automatically scale in or out depending on demand</li>
            <li>
              High availability - resources are served from redundant physical servers which reside in multiple locations,
              limiting downtime in case some fail
            </li>
            <li>Pay-for-use billing - billing is based on consumption, which may include compute time, stored data or data transfer</li>
            <li>No infrastructure management</li>
          </ul>
          <p>
            Small teams with limited DevOps experience can benefit from the simplicity of managing serverless applications.
            Other applications, especially those with very bursty traffic, can benefit from the auto-scaling and pay-for-use
            nature of serverless resources.
          </p>
          <p>
            However deployment considerations mark a major difference between serverless and non-serverless applications.
            Consider converting a three-tier application to a serverless application; what was a single web server may now consist
            of an API gateway and a bundle of serverless functions. The application server is also a bundle of serverless functions,
            and the HTML it used to serve may be stored in a geographically-distributed object storage service for static assets.
          </p>
          <p>
            Deploying this application will be very different from deployment in the on-premise and cloud-hosted models.
            In those approaches, infrastructure is only defined and provisioned once: when purchasing physical on-prem equipment
            or when provisioning long-running cloud resources. But for serverless applications, only the resource definitions are persistent.
            These definitions are stored by the cloud provider so that corresponding infrastructure components can be provisioned on demand
            and only as needed. Moreover, deployment environments for a serverless application cannot simply be managed as separate sets
            of persistent application infrastructure. Consequently, deployment pipelines for a serverless application need to maintain
            the logical separation of deployment environments and their unique resources despite them all being ephemeral and distributed
            in nature. This can be accomplished by provisioning distinct copies of each serverless resource, effectively deploying a separate,
            fully-functioning version of the application for each deployment environment.
          </p>
          <p>
            Development environments present a larger issue - no longer can a developer simply run a local version of their
            application because it is difficult, if not impossible, to recreate the network and compute conditions of an
            inherently-distributed serverless application. While local mocking solutions for cloud environments do exist<a href="#reference-12"><sup>12</sup></a>,
            the best way to see how an application performs in a distributed cloud environment is by running it in a distributed
            cloud environment<a href="#reference-13"><sup>13</sup></a>. Thus, running a development environment that more closely matches staging and production improves
            the developer experience. Fortunately, the pay-for-use model of serverless also means that these development environments
            will not incur costs as high as those of the production environment which is exposed to public traffic, even if it is composed
            of the same resources.
          </p>
          <img
            class="lazy"
            data-src="images/diagrams/section1/serverless.png"/>
          <p>
          <h3 id="section-1-8">1.8 Existing Tools</h3><p>
            Unsurprisingly, there are a number of tools designed to offer deployment pipeline solutions,
            each with their strengths and weaknesses.
          </p>
          <img class="lazy"
          data-src="images/diagrams/section1/comparison-no-trellis.png"/>
          <p>
            One option is for teams to use open-source tools to develop an automated deployment pipeline in-house.
            These DIY solutions can be attractive to those who want a fully-customized pipeline that tightly integrates
            with their particular development workflow, but they require a significant time investment to build.
            There are free, open-source automation platforms like Jenkins or Red Hat's Ansible which aim to speed up the DIY approach,
            but these tools still take considerable time to research and answer questions like “What is the scope of the platform?”
            and “Which of its available tools and plugins are relevant to the use case at hand?”
            In general, in-house solutions are cheaper and highly-customizable, but are more complex to set up.
            This is impractical for smaller teams who don't have the bandwidth to design and manage an entire deployment application
            on top of their regular responsibilities.
          </p>
          <p>
            Another class of options are third-party or SaaS deployment pipelines such as TravisCI or CircleCI.
            These pre-configured tools accommodate a wide range of deployment scenarios and preferences by providing
            feature-rich platforms for developing, testing, and releasing projects.
            However, this comprehensive personalization comes at a price.
            Namely, these solutions require paid plans that can be costly.
            It can also be difficult to navigate their complex workflows, wide feature sets and available plugins.
          </p>
          <p>
            There also exist products targeting smaller niches, such as Seed (seed.run).
            Seed is a SaaS deployment pipeline designed for serverless applications in particular.
            Out of the box, it supports a more-narrow set of development methods than Jenkins, Ansible, CircleCI andTravisCI,
            and as a result has a comparatively lower configuration complexity. It is heavily-opinionated in that it only supports
            applications built on the Serverless Framework or the Serverless Stack (SST) framework, only accepts code from three
            of the most popular version control systems, and only deploys applications to AWS.
            While these limitations render Seed unsuitable for many software development workflows,
            they enable Seed to abstract away most of the complexity for its target users.
            Out of the box, it requires no buildspec files or deployment scripts, enables multiple environments per app,
            and provides a simple web-based dashboard for managing and monitoring deployments with just a few clicks.
          </p>
          <p>
            Seed is a mature tool with many features<a href="#reference-14"><sup>14</sup></a>. For example, it offers email and webhook deployment notifications,
            supports multiple version control systems, and provides metrics for serverless functions and serverless APIs
            <a href="#reference-15"><sup>15</sup></a><a href="#reference-16"><sup>16</sup></a>.
            But tools like Seed are not without their drawbacks. For example, Seed owns and operates its own pipeline infrastructure completely.
            Because of this, users do not have complete control over their build servers or the databases that store sensitive information
            such as build metadata, environment variables, and AWS IAM credentials. Further, Seed is not open-source,
            meaning there is almost no recourse for users who want to tweak or customize the underlying code.
            For instance, there is no way to alter the memory configuration of a build server or specify a particular region
            in which a deployment should occur. In essence, when teams use a tool like Seed, they put full trust in its ability
            to keep their information secure and predict all user needs in advance. Not all teams will be comfortable providing
            this level of trust; some will need a solution that is as opinionated and low-config as Seed, but with a different set
            of tradeoffs that give the user full control of the pipeline's infrastructure and the data that it relies on.
            We built Trellis to meet this need.
          </p>
          <img class="lazy"
          data-src="images/diagrams/section1/comparison-trellis.png" />

          <!-- Section 2 -->
          <h2 id="section-2">2. Enter Trellis</h2>
          <img  class="lazy"
          data-src="images/diagrams/section2/architecture.png"/>
          <h3 id="section-2-1">2.1 What is Trellis?</h3>
          <p>
            Trellis is a low-config, continuous delivery deployment pipeline for teams who develop serverless applications on AWS.
            It handles the complexity of setting up automated deployment pipelines for its users, making it suitable for teams
            who want to spend less time on operations and more time on feature development. As an open-source and self-hosted application,
            Trellis users get a low-config deployment pipeline out of the box and still maintain control of their data. 
          </p>
          <h3 id="section-2-2">2.2 What Can Trellis Do?</h3>
          <img src="images/diagrams/section2/showcase.jpg"  class="rounded-corners" height="#" />
          <h4>Get Code From GitHub</h4>
          <p>
            When users log into Trellis, they can create new applications and specify a GitHub repository that provides each
            application's source code. By default, each new application gets three deployment environments - development, staging,
            and production - and more can be defined in settings. The development environment is connected to the selected repository's
            main branch so that commits to main can be quickly deployed to a cloud environment. Users can configure other git branches
            to provide source code to each deployment environment as desired. 
          </p>
          <img src="images/diagrams/section2/configure_github.png" class="rounded-corners" height="#" />
          <h4>Deploy</h4>
          <p>
            When code is committed to an application's GitHub repository, Trellis automatically starts deploying the new code
            to any environment that is configured to deploy that branch. If users want to deploy a commit that occurred before Trellis
            was configured, users can manually deploy the most-recent commit for any branch.
          </p>
          <img src="images/diagrams/section2/deploy.jpg"  class="rounded-corners" height="#" />
          <h4>Promote</h4>
          <p>
            With the click of a button, Trellis users can promote code to the next environment once its developers are confident
            in its performance. Because pushing new versions to production without approval can harm the business by exposing end
            users to errors, bugs, or problematic infrastructure changes, Trellis ensures that the production environment is not
            configured for automatic deployments. Manual promotion to production is the only way to deploy an application to end users.
          </p>
          <img src="images/diagrams/section2/promote.jpg"  class="rounded-corners" height="#" />
          <h4>Teardown</h4>
          <p>
            In some instances, Trellis users might deploy their code, only to decide that it needs to be developed further and should
            not proceed through the pipeline. There is no need to leave the application running in such cases,
            so Trellis equips each deployment environment with a teardown button for removing all of the cloud resources associated with
            a deployed application.
          </p>
          <img src="images/diagrams/section2/teardown.jpg"   class="rounded-corners" height="#" />
          <h4>Rollback</h4>
          <p>
            Sometimes, problematic code will be deployed to an environment and the development team will want to revert the environment
            back to a previously-trusted application version. For instance, if a mis-typed database query breaks an application's
            functionality, end users should be insulated from the change and served an older version instead.
            Trellis anticipates these scenarios and provides a rollback button for all deployment environments.
            Users can click this button and select a previous application version to re-deploy, or “roll back” to.
          </p>
          <img src="images/diagrams/section2/rollback.jpg" class="rounded-corners" />
          <h4>Test</h4>
          <p>
            Unit tests can give confidence that code is behaving as expected.
            If the tests are comprehensive and the code is passing the tests, then developers can have confidence that things are
            working as expected. In Trellis, users can toggle unit testing for each deployment environment so they can see the output
            of the `npm run test` command each time a deployment takes place. If they need to run tests via a different command,
            they can configure that too.
          </p>
          <img src="images/diagrams/section2/run_tests.jpg" class="rounded-corners" />

          <h3 id="section-2-3">2.3 What is Trellis Composed Of?</h3>
          <p>
            With its features, Trellis solves the problem of validating code changes and putting them into environments where
            they can be promoted through a deployment pipeline to production. Three high-level components work together to fulfill
            this responsibility: a build server, a dashboard, and a backend.
          </p>
            <h4>The Build Server</h4>
                <img  class="lazy" data-src="images/diagrams/section2/build-server.png"  height="200"/>
              <p>
                Trellis' build server executes deployments to their target environments from an isolated machine and ensures
                that unique cloud resources are provisioned for each environment. This build server also performs teardowns
                and rollbacks for all deployment environments as requested by users. Executing these jobs on isolated machines
                ensures consistent reliability as there is no opportunity for a developer or their local tools and dependencies
                to interfere with the process.
              </p>
            <h4>The Backend</h4>
                <img class="lazy" data-src="images/diagrams/section2/backend.png"  height="200"/>
              <p>
                The backend facilitates communication between the build server and the dashboard.
                Its database stores user login information, environment-specific settings, GitHub repository data,
                deployment environment status (e.g. deploying, deployed, tearing down), and logged output from the build server.
                Its API is responsible for initiating the build server, updating the database, and passing relevant data between
                the dashboard and build server so they can carry out their respective duties. 
              </p>
            <h4>The Dashboard</h4>
            <div class="component-container">
              <div class="image">
                <img  class="lazy" data-src="images/diagrams/section2/dashboard.png"  height="200"/>
              </div>
              <p>
                Trellis' dashboard gives users a way to interact with their deployment pipelines. It displays the state of the
                deployment pipelines to users, provides configuration settings for customizing and managing their deployment environments,
                and displays controls for managing all of the pipeline's features and triggering any manual steps of their pipelines.
              </p>
              </div>

          <!-- Section 3 -->
          <h2 id="section-3">3. Architecture</h2>
          <h3 id="section-3-1">3.1 Trellis as a Serverless Application</h3>
          <p>
            As a deployment pipeline for small teams, Trellis is subjected to bursty traffic as its users are unlikely
            to be deploying applications all day long. Therefore, they should not have to pay for long-standing servers
            to run Trellis around the clock. Nonetheless, Trellis should still be ready for action at a moment's notice.
            Recognizing these needs, we designed Trellis with a serverless architecture that runs on Amazon Web Services (AWS).
            Accordingly, Trellis is scalable, can execute concurrent deployments as needed, and will be completely inactive
            while its users are not using it. Furthermore, Trellis' target users are teams that deploy serverless applications using AWS,
            and they can more-easily adopt and integrate Trellis into their existing workflows because it utilizes the same cloud provider
            and cloud-based resources that they already work with. Furthermore, if users find the need to adjust how Trellis is configured
            or customize any of its components down the road, they are more capable of doing so if its architecture uses a familiar paradigm.
          </p>
          <p>
            As mentioned earlier, the resources that constitute serverless applications should be ephemeral,
            meaning that after performing their respective tasks, they are deprovisioned entirely.
            This requirement has major implications for our architectural decisions when designing Trellis' main components,
            which we will outline below.
          </p>
          <h3 id="section-3-2">3.2 Build Server</h3>
          <p>
            Deployment pipelines traditionally use a dedicated build server to run the build process and deploy users' applications.
            Trellis is serverless and thus does not have a dedicated long-standing build server.
            Nonetheless, we will continue to refer to the architecture components responsible for the deployments, teardowns,
            and rollbacks as a build server. 
          </p>
          <p>
            Recall that the build server needs to perform various functions, including retrieving code from the source code repository,
            running necessary unit tests, and deploying code to a deployment environment. 
          </p>
            Trellis' build server is implemented as an AWS Fargate task, which offers on-demand computing via containers.
            Containers are stand-alone, executable software packages that include an application
            and all the dependencies it needs to run<a href="#reference-17"><sup>17</sup></a>,
            while images are templates that can be used to create containers. Each time it is invoked,
            the Fargate task spins up a new container based on an image that is provided by Trellis and stored in the
            AWS Elastic Container Registry. 
          <p>
            Each container has access to a sandboxed file system that it can use to clone source code from GitHub,
            install application dependencies, and execute deployment-related commands. Build server containers are scaled in and out
            according to incoming requests - in our case, each deployment to an environment invokes a new Fargate task so that
            all deployments remain consistent and each one occurs in a fresh, isolated environment.
            Finally, they are deprovisioned once they have completed their work.
          </p>
          <p>
            Each build server task needs several pieces of data about the deployment to complete its job. Among this data are:
          </p>
          <ul>
            <li>
              The type of build action (promotion, teardown, rollback)
            </li>
            <li>
              An identifier of the specific version of code to be cloned from GitHub and deployed to the cloud
            </li>
            <li>
              The name of the target deployment environment, which is prepended to the names of the resulting AWS resources
              to logically associate them with their environment
            </li>
            <li>
              Metadata about the deployment pipeline, such as the application name, whether unit tests should be run,
              and any environment variable the application uses
            </li>
          </ul>
          <p>
            Trellis' backend is responsible for triggering the build server. This involves gathering deployment data,
            initiating a Fargate task, and dynamically injecting the data into the task's corresponding container as environment variables.
          </p>
          <p>
            For Trellis to deploy AWS resources on behalf of its users, it must have both create and delete permissions
            for all services used within their applications. Trellis stores these credentials using AWS Secrets Manager,
            which requires that users or resources be given affirmative permission to access secrets.
            Each build server container uses the AWS Software Development Kit (SDK) to programmatically access Trellis secrets,
            which are stored with the prefix ‘trellis/`. Build server containers only have permission to access secrets with this prefix. 
          </p>
          <p>
            Trellis' build process is built atop an Infrastructure-as-Code (IaC) tool known as the Serverless Stack (SST) framework,
            which itself is an abstraction built atop Amazon's Cloud Development Kit(CDK).
            IaC tools enable developers to specify resources using a familiar programming language, as opposed to manually
            deploying resources individually on the AWS dashboard. When using IaC, the source code itself contains instructions
            for what resources to deploy and how they should be connected, leaving less room for human error as resource
            definitions can be written once and then shared or reused indefinitely.
          </p>
          <video autoplay loop muted playsinline>
            <source src="images/video/3-2-infrastructure-as-code-temp.mp4" type="video/mp4" />
          </video>
          <figcaption>Infrastructure as Code</figcaption>
          <p>
            IaC tools typically also offer commands for deploying the application and the cloud resources it relies on.
            SST includes such commands, along with several other features like that make it easier to develop serverless applications on AWS.
            Trellis deploys SST apps in particular, so it uses SST commands on the build server to deploy the users' applications.
            Logs of the entire build server process, including the SST commands, are sent to AWS CloudWatch, Amazon's log storage service,
            to be streamed to the user's dashboard.
          </p>
          <img  class="lazy" data-src="images/diagrams/section3/buildServer.png">


          <h3 id="section-3-3">3.3 Backend</h3>
          <p>
            Trellis backend is a collection of serverless functions, an API gateway and a serverless database. 
          </p>
          <p>
            The bulk of Trellis's backend is composed of multiple Lambda Functions. Lambda functions
            are individually-defined units of executable logic. When a Lambda is invoked,
            the cloud provider runs that function's logic in a container.
            The infrastructure that runs each function is provisioned and deprovisioned according to incoming demand,
            and AWS scales the number of functions responding to requests to match incoming traffic flow.
          </p>
          <figure>
            <img  class="lazy" data-src="images/diagrams/section3/backend.png">
            <figcaption>The backend is a collection of AWS Lambda functions, an API Gateway and an AWS DynamoDB </figcaption>
          </figure>
          <p>
            There are separate lambda functions for managing each of Trellis responsibilities, including:
          </p>
          <ul>
            <li>
              Adding new users
            <li>
              Creating new applications
            </li>
            <li>
              Retrieving an application's environments
            </li>
            <li>
              Promoting a development environment to production
            </li>
            <li>
              Authenticating users through GitHub
            </li>
            <li>
              Retrieving a list of user's repositories, and so on.
            </li>
          </ul>
          <p>
            Trellis uses AWS API Gateway as the “front door” to its backend. AWS API Gateway is a service that makes
            it easy for developers to create and secure APIs<a href="#reference-18"><sup>18</sup></a>.
            An API Gateway can accept incoming HTTP requests and has Lambda functions associated with its URL endpoints.
            These Lambdas are invoked to process requests and, if necessary, compose responses.
          </p>
          <p>
            Among the Lambda functions that the API Gateway invokes is the “automatic deployment” Lambda.
            Trellis implements automatic deployments by registering a webhook URL on all GitHub repositories that are connected
            to a Trellis application. Webhooks are notifications sent over HTTP, allowing systems like Trellis to respond to
            events as they occur instead of querying for changes. The webhook is configured to send a request to the API Gateway
            whenever a new commit occurs on a GitHub branch. The API Gateway then invokes the “automatic build”
            Lambda which checks if any deployment environment is associated with that branch.
            If so, it triggers the build server to start deploying the code for that commit.
          <p>
            To execute automatic deployments along with all other functionalities,
            Trellis needs to store data about the deployment pipelines it is managing, including data regarding users,
            applications, environments, and deployments. Trellis stores this data in AWS DynamoDB,
            a serverless AWS key-value NoSQL database. The information stored in the database includes the user's GitHub token,
            an application's repository, a deployment status, and other such metadata.
          </p>
          <h3 id="section-3-4">3.4 Dashboard</h3>
          <p>
            We built the Trellis dashboard as a single-page application in React.
            This means that all dashboard users get the same copy of the dashboard HTML,
            but the data is populated by making calls to Trellis' backend. This allowed us to store the dashboard HTML in an AWS S3 bucket.
            S3<a href="#reference-19"><sup>19</sup></a> is Amazon's object storage service.
            Static files, such as our dashboard HTML, can be retrieved directly from an S3 bucket.
            Our dashboard is served using AWS CloudFront<a href="#reference-20"><sup>20</sup></a>, Amazon's content delivery network.
            Using S3 and CloudFront in this way allowed us to avoid using a long-running web server to serve the dashboard HTML.
          </p>
          <p>
            Trellis users utilize the dashboard to trigger any of their pipelines' manual steps, including promotions, rollbacks,
            and teardowns. The dashboard also provides a settings page for each deployment environment so that users can provide
            environment variables to the build server, specify different AWS credentials for each deployment, toggle unit testing,
            and more. Moreover, the dashboard starts a WebSocket connection with the backend's API Gateway to convey the state of
            deployments to Trellis users.
          </p>
          <figure>
            <img src="images/diagrams/section3/dashboard.png">
            <figcaption>The dashboard code is stored in AWS S3 and served via AWS CloudFront</figcaption>
          </figure>

          <!-- Section 4 -->
          <h2 id="section-4">4. Engineering Decisions & Tradeoffs</h2>
          <p>
            Now that we understand the architecture of Trellis, this section will discuss some challenges faced
            in implementing this architecture.
          </p>
            <h3 id="section-4-1">4.1 Build Server: Lambda vs Fargate</h3>
            <p>
              As mentioned above, Trellis does not have a persistent build server waiting around to execute deployments.
              Instead, we needed a service that could provision build servers dynamically to execute deployment logic on demand.
              We considered two AWS services to fulfill this need: AWS Lambda and AWS Elastic Container Service with Fargate.
            </p>
            <p>
              Lambda functions have access to an underlying file system, can execute the commands to build and deploy applications,
              and also has the auto-scaling characteristics we need for our build server.
              With these characteristics, Lambda seemed like a potential fit for handling our build server's duties.
              However, Lambdas are limited to 15<a href="#reference-21"><sup>21</sup></a> minutes of runtime.
              Even deploying a modestly-sized application such as Trellis itself exceeded that time limit;
              hence, they are ill-suited for Trellis.
            </p>
            <p>
              Our solution to avoiding the Lambda timeout limit was to utilize an AWS ECS Fargate task instead.
              Like Lambda, Fargate offers an on-demand compute engine for executing logic.
              Logic must be containerized by developers before it can run on Fargate,
              making Fargate slightly more-complicated than Lambda in terms of setup<a href="#reference-22"><sup>22</sup></a>.
              But this is a justifiable tradeoff considering that Fargate tasks are not subject to timeouts.
              While the start-up times of ECS Fargate tasks is significantly greater than Lambdas (around a minute for
              ECS Fargate tasks and under a second for Lambdas), the relatively long duration of the build process makes
              this a negligible tradeoff. Otherwise, an ECS Fargate task is well-suited for executing builds and deployments -
              we can spin up a task only when needed, and a containerized build server will be spun up to handle the deployment at hand.
              Furthermore, the auto-scaling nature of ECS means that Trellis can handle concurrent deployments out of the box.
            </p>
          <h3 id="section-4-2">4.2 Sending real-time data to the dashboard</h3>
          <figure>
            <img src="images/diagrams/section4/logs.png">
          </figure>
          <p>
            In addition to providing a way to trigger deployments manually, the Trellis dashboard provides
            users with information about the state of their deployment pipelines, including logs of the deployment process.
            We recognized that this information should be as recent as possible so users can stay up-to-date on the progress
            and status of their deployments. However, given that Trellis is composed of multiple ephemeral components,
            sending deployment information to users in real time required efforts to facilitate real-time communication
            between these components. To stream logs to the user in Trellis architecture, we needed to both retrieve the
            deployment state as it changes and then send the updated state to the user in real-time. 
          </p>
          <figure>
            <video autoplay loop muted playsinline>
              <source src="images/video/4-2-flow-of-a-deployment-in-trellis.mp4" type="video/mp4" />
            </video>
            <figcaption>Flow of a deployment request in Trellis</figcaption>
          </figure>
          <!-- <figure>
            <video src="images/diagrams/section4/flowOfDeploymentRequest">
          </figure> -->
          <div id="retrieving-deployment-state-from-the-build-server">
            <h4>Retrieving deployment state from the build server</h4>
            <p>
              In the initial prototype of Trellis, the build server sent deployment state updates to the database in batches,
              only dispatching new logs after executing each command in the build process.
              The deployment command provided by SST compiles the application code down to resource templates.
              These templates are sent to AWS CloudFormation,
              which uses them to provision the resources defined in them<a href="#reference-23"><sup>23</sup></a>.
              Provisioning the resources with a single SST command may take over 20 minutes<a href="#reference-24"><sup>24</sup></a>.
              Consequently, waiting to log the output of the deployment command meant that the user could wait a long time
              before finding out whether their deployment occurred as expected. In other words,
              the logs and deployment status as shown on the dashboard did not necessarily reflect the current state of the deployment.
            </p>
            <figure>
              <video autoplay loop muted playsinline>
                <source src="images/video/4-3-sending-deployment-logs-in-batches.mp4" type="video/mp4" />
              </video>
              <figcaption>Sending deployment logs in batches</figcaption>
            </figure>
            <p>
              To address this issue, we could have retrieved the state of resource deployments directly from CloudFormation.
              The CloudFormation console can be configured to send notifications whenever there is a change to the state
              of a particular resource in the cloud. As such, we considered sending deployment updates to the front-end after each
              of these notifications. However, CloudFormation only provides information on AWS infrastructure changes,
              which is just a partial picture of the Trellis deployment process. As mentioned earlier,
              the build server performs other tasks before issuing the SST deployment command; we wanted users
              to access the status and outputs of those commands as well. Doing so would ensure that the user
              has visibility of the entire deployment process, not just the resources being provisioned in AWS.
              For instance, they would know if the deployment process is disrupted by any errors thrown while commands
              are executed on the build server.
            </p>
            <p>
              While the build server is executing the deployment command, it makes frequent calls to CloudFormation
              to get resource deployment state and logs this information. The build server also creates logs related
              to the other build process commands, such as cloning the GitHub repository or installing the application dependencies.
              By capturing the build server's logs, we can gain a comprehensive real-time picture of the deployment status. 
            </p>
            <p>
              We used AWS CloudWatch to achieve this result. CloudWatch enables the connection of a specific AWS resource to a log group,
              which is composed of separate log streams connected to a particular instance of that resource.
              The logs of each ECS Fargate task are written to its connected log stream as they occur. 
            </p>
            <p>
              Whenever there is an update within a log group, Cloudwatch publishes a log event that other AWS resources
              can subscribe and react to. A Lambda function is configured to respond to events from this log group.
              When this Lambda is triggered, it writes the logs to the database, enabling Trellis to send them to the client as they occur.
            </p>
            <figure>
              <video autoplay loop muted playsinline>
                <source src="images/video/4-4-streaming-deployment-logs.mp4" type="video/mp4" />
              </video>
              <figcaption>Streaming deployment logs</figcaption>
            </figure>
          </div>
          <div id="sending-deployment-state">
            <h4>Sending Deployment State</h4>
            <p>
              Now that we have near real time logs in the backend, Trellis must pass this information to users of the dashboard.
              We considered achieving this via either client-side polling or WebSockets.
            </p>
            <figure>
              <img src="images/diagrams/section4/polling_new.png">
            </figure>
            <p>
              In client-side polling, the client repeatedly queries the (backend/server) for data,
              often at regular intervals of a few seconds. Client-side polling is straightforward to implement,
              as it only requires that the client be configured to send HTTP requests at a regular interval.
              However, consistently polling for data can generate unnecessary HTTP requests,
              and the polling interval can introduce a delay between updates on the backend and the front-end.
            </p>
            <figure>
              <img src="images/diagrams/section4/websocket.png">
            </figure>
            <p>
              WebSockets, on the other hand, allow for bidirectional communication between a client and a server.
              Rather than the client needing to send repeated requests to the server,
              a persistent connection between client and server is maintained so that the server can send the data
              to the client as soon as it is available. In the case of Trellis,
              we utilized the AWS WebSocket API which relies on an API gateway to persist open connections
              between clients and the backend AWS services.
              When the build server sends logs to a CloudWatch log group,
              the Lambda function that is subscribed to that log group sends data through this WebSocket connection
              to the client, providing real-time updates to the client regarding the state of their deployments.
            </p>
            <figure>
              <video autoplay loop muted playsinline>
                <source src="images/video/4-7-logs-sent-through-aws-resources-client-over-websocket.mp4" type="video/mp4" />
              </video>
              <figcaption>Logs are sent through several AWS resources before being sent to the client over the open WebSocket connection</figcaption>
            </figure>
          </div>
   
          <!-- Section 5 -->
          <h2 id="section-5">5. Future Work</h2>
          <p>
            Trellis is a fully-functioning low-config, self-hosted, and team-oriented automated deployment pipeline.
            Nevertheless, there is always room for software to improve.
            Below are some features we would like to implement in later iterations of Trellis.
          </p>
          <ul>
            <li>
              Implement user roles with customizable permissions for each role
            </li>
            <li>
              Optimize deployment times 
              <ul>
                <li>
                  Cache dependencies (e.g., Node Modules) in a shared file system to avoid re-downloading for every deployment
                </li>
                <li>
                  Store build artifacts, so rollbacks don't require rebuilding an older application version
                </li>
              </ul>
            </li>
            <li>
              Offer a simple CLI for developers to manage and monitor deployments from a local console
            </li>
            <li>
              Allow users to connect Trellis to their Continuous Integration service in cases where their
              serverless application is one part of a larger application with non-serverless components
            </li>
          </ul>


           <!-- Section 6 -->
            <h2 id="section-6">6. References</h2>
            <ol class="indented">
              <li id="reference-1"><a target="_" href="https://www.atlassian.com/devops" style=>https://www.atlassian.com/devops</a></li>
              <li id="reference-2"><a target="_" href="https://www.atlassian.com/continuous-delivery/continuous-integration" style=>https://www.atlassian.com/continuous-delivery/continuous-integration</a></li>
              <li id="reference-3"><a target="_" href="https://aws.amazon.com/devops/continuous-delivery/" style=>https://aws.amazon.com/devops/continuous-delivery/</a></li>
              <li id="reference-4"><a target="_" href="https://medium.com/@gwright_60924/software-delivery-101-environments-and-applications-8fff2c4e2524" style=>https://medium.com/@gwright_60924/software-delivery-101-environments-and-applications-8fff2c4e2524</a></li>
              <li id="reference-5"><a target="_" href="https://www.itprotoday.com/devops-and-software-development/development-staging-and-production-model" style=>https://www.itprotoday.com/devops-and-software-development/development-staging-and-production-model</a></li>
              <li id="reference-6"><a target="_" href="https://vshosting.eu/blog/development-and-production-why-separate-them-at-all-costs" style=>https://vshosting.eu/blog/development-and-production-why-separate-them-at-all-costs</a></li>
              <li id="reference-7"><a target="_" href="https://dltj.org/article/software-development-practice/" style=>https://dltj.org/article/software-development-practice/</a></li>
              <li id="reference-8"><a target="_" href="https://www.martinfowler.com/articles/continuousIntegration.html" style=>https://www.martinfowler.com/articles/
                continuousIntegration.html</a></li>
              <li id="reference-9"><a target="_" href="https://www.rackspace.com/sites/default/files/white-papers/national-kidney-registry-steams-with-rackspace-to-make-miracle-matches.pdf" style=>https://www.rackspace.com/sites/default/files/
                white-papers/national-kidney-registry-steams-with-rackspace-to-make-miracle-matches.pdf</a></li>
              <li id="reference-10"><a target="_" href="https://martinfowler.com/articles/serverless.html#WhatIsServerless" style=>https://martinfowler.com/articles/
                serverless.html#WhatIsServerless</a></li>
              <li id="reference-11"><a target="_" href=" https://aws.amazon.com/serverless/" style=>https://aws.amazon.com/serverless/</a></li>
              <li id="reference-12"><a target="_" href="https://github.com/localstack/localstack" style=>https://github.com/localstack/localstack</a></li>
              <li id="reference-13"><a target="_" href="https://serverlessfirst.com/emails/testing-serverless-backends-survey-results-+-the-local-vs-cloud-debate/" style=>https://serverlessfirst.com/emails/
                testing-serverless-backends-survey-results-+-the-local-vs-cloud-debate/</a></li>
              <li id="reference-14"><a target="_" href=" https://seed.run/pricing" style=> https://seed.run/pricing</a></li>
              <li id="reference-15"><a target="_" href="https://seed.run/docs/viewing-metrics" style=>https://seed.run/docs/viewing-metrics</a></li>
              <li id="reference-16"><a target="_" href="https://seed.run/docs/adding-build-notifications" style=>https://seed.run/docs/adding-build-notifications</a></li>
              <li id="reference-17"><a target="_" href="https://www.docker.com/resources/what-container/" style=>https://www.docker.com/resources/what-container/</a></li>
              <li id="reference-18"><a target="_" href="https://aws.amazon.com/api-gateway/" style=>https://aws.amazon.com/api-gateway/</a></li>
              <li id="reference-19"><a target="_" href="https://aws.amazon.com/s3/" style=>https://aws.amazon.com/s3/</a></li>
              <li id="reference-20"><a target="_" href="https://aws.amazon.com/cloudfront/" style=>https://aws.amazon.com/cloudfront/</a></li>
              <li id="reference-21"><a target="_" href="https://docs.aws.amazon.com/lambda/latest/dg/gettingstarted-limits.html" style=>https://docs.aws.amazon.com/lambda/latest/
                dg/gettingstarted-limits.html</a></li>
              <li id="reference-22"><a target="_" href="https://www.simform.com/blog/aws-fargate-vs-lambda/" style=>https://www.simform.com/blog/aws-fargate-vs-lambda/</a></li>
              <li id="reference-23"><a target="_" href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/cfn-whatis-howdoesitwork.html" style=>https://docs.aws.amazon.com/
                AWSCloudFormation/latest/UserGuide/cfn-whatis-howdoesitwork.html</a></li>
              <li id="reference-24"><a target="_" href="​​https://seed.run/blog/speeding-up-serverless-deployments-100x.html" style=>https://seed.run/blog/speeding-up-serverless-deployments-100x.html</a></li>
            </ol>
        </div>
      </div>
    </div>

    <div id="presentation" class="main-section">
      <div class="bg-gray">
        <h2>Presentation</h2>
        <p>will be made available soon</p>
        <!-- <iframe
          src="#"
          title="YouTube video player"
          frameborder="0"
          allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
          allowfullscreen
        ></iframe> -->
      </div>
    </div>

    <div id="our-team" class="main-section">
      <div>
        <div>
          <div>
            <h2>Meet our team</h2>
            <p class="text-xl text-gray-300">
              We are currently looking for opportunities. If you liked what you
              saw and want to talk more, please reach out!
            </p>
          </div>
          <ul class="people">
            <li class="profile">
              <img
                class="mx-auto h-40 w-40 rounded-full xl:w-56 xl:h-56 lazy"
                data-src="images/team/ma.png"
                alt=""
              />
              <div>
                <div>
                  <h3>Marcos Avila</h3>
                  <p>New York City, NY, USA</p>
                </div>

                <ul class="social">
                  <li>
                    <a href="mailto:marcosavila@protonmail.com" target="_blank"
                      ><i class="fas fa-envelope"></i
                    ></a>
                  </li>
                  <li>
                    <a
                      href="https://www.linkedin.com/in/avilamarcos"
                      target="_blank"
                      ><i class="fab fa-linkedin"></i
                    ></a>
                  </li>
                  <li>
                    <a href="https://github.com/Maru-ko" target="_blank"
                      ><i class="fab fa-github"></i
                    ></a>
                  </li>
                  <li>
                    <a href="https://marcosavila.com/" target="_blank"
                      ><i class="fas fa-globe"></i
                    ></a>
                  </li>
                </ul>
              </div>
            </li>

            <li class="profile">
              <img
                class="mx-auto h-40 w-40 rounded-full xl:w-56 xl:h-56 lazy"
                data-src="images/team/mel.png"
                alt=""
              />
              <div>
                <div>
                  <h3>Mohamad El-Chanti</h3>
                  <p>Toronto, ON, Canada</p>
                </div>

                <ul class="social">
                  <li>
                    <a href="mailto:m.elchanti@gmail.com" target="_blank"
                      ><i class="fas fa-envelope"></i
                    ></a>
                  </li>
                  <li>
                    <a
                      href="https://www.linkedin.com/in/mohamadelchanti/"
                      target="_blank"
                      ><i class="fab fa-linkedin"></i
                    ></a>
                  </li>
                  <li>
                    <a href="https://github.com/melchanti" target="_blank"
                      ><i class="fab fa-github"></i
                    ></a>
                  </li>
                  <li>
                    <a href="http://www.dev.mohamadel-chanti.com/" target="_blank"
                      ><i class="fas fa-globe"></i
                    ></a>
                  </li>
                </ul>
              </div>
            </li>

            <li class="profile">
              <img
                class="mx-auto h-40 w-40 rounded-full xl:w-56 xl:h-56 lazy"
                data-src="images/team/mg.png"
                alt=""
              />
              <div>
                <div>
                  <h3>Martin Graham</h3>
                  <p>Waco, Texas, USA</p>
                </div>

                <ul class="social">
                  <li>
                    <a href="mailto:martin.anderson.graham@gmail.com" target="_blank"
                      ><i class="fas fa-envelope"></i
                    ></a>
                  </li>
                  <li>
                    <a
                      href="https://www.linkedin.com/in/martin-graham-002353104/"
                      target="_blank"
                      ><i class="fab fa-linkedin"></i
                    ></a>
                  </li>
                  <li>
                    <a href="https://github.com/martin-anderson-graham" target="_blank"
                      ><i class="fab fa-github"></i
                    ></a>
                  </li>
                  <li>
                    <a href="http://martingraham.dev/" target="_blank"
                      ><i class="fas fa-globe"></i
                    ></a>
                  </li>
                </ul>
              </div>
            </li>

            <li class="profile">
              <img
                class="mx-auto h-40 w-40 rounded-full xl:w-56 xl:h-56 lazy"
                data-src="images/team/cw.png"
                alt=""
              />
              <div>
                <div>
                  <h3>Cody Williams</h3>
                  <p>Los Angeles, CA, USA</p>
                </div>

                <ul class="social">
                  <li>
                    <a href="mailto:cody@codywilliams.dev" target="_blank"
                      ><i class="fas fa-envelope"></i
                    ></a>
                  </li>
                  <li>
                    <a
                      href="https://linkedin.com/in/williamscody"
                      target="_blank"
                      ><i class="fab fa-linkedin"></i
                    ></a>
                  </li>
                  <li>
                    <a href="https://github.com/Code-yWilliams" target="_blank"
                      ><i class="fab fa-github"></i
                    ></a>
                  </li>
                  <li>
                    <a href="https://codywilliams.dev" target="_blank"
                      ><i class="fas fa-globe"></i
                    ></a>
                  </li>
                </ul>
              </div>
            </li>
          </ul>
        </div>
      </div>
    </div>

    <script src="javascripts/script.js"></script>
  </body>
</html>
